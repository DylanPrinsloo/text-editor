Parsing is the process of analyzing a sequence of tokens generated by a lexer to determine its grammatical structure according to a given formal grammar. Different parsing techniques are used to build parse trees or abstract syntax trees (ASTs) from source code. Here’s an overview of some common parsing techniques:

### 1. **Recursive Descent Parsing**
   - **Overview**: Recursive descent parsing is a top-down parsing technique where each non-terminal in the grammar is represented by a function in the parser. The parser starts with the start symbol and recursively expands it into the terminal symbols by calling the corresponding functions.
   - **How It Works**:
     - Each function corresponds to a non-terminal in the grammar.
     - The parser uses a function call stack to process the input tokens.
     - The functions match the input tokens against the expected patterns, consuming tokens and calling other functions as necessary.
   - **Example**:
     - Consider a grammar for simple arithmetic expressions:
       ```plaintext
       Expr  -> Term | Term '+' Expr
       Term  -> Factor | Factor '*' Term
       Factor -> '(' Expr ')' | NUMBER
       ```
     - The corresponding recursive descent functions might look like this:
       ```python
       def expr():
           term()
           if current_token == '+':
               match('+')
               expr()
       
       def term():
           factor()
           if current_token == '*':
               match('*')
               term()
       
       def factor():
           if current_token == '(':
               match('(')
               expr()
               match(')')
           elif current_token == 'NUMBER':
               match('NUMBER')
       ```
   - **Advantages**:
     - Simple to implement and understand.
     - Works well for grammars that do not have left recursion.
   - **Disadvantages**:
     - Cannot handle left-recursive grammars without modification.
     - Backtracking can be inefficient in certain cases.

### 2. **LL Parsing (Left-to-right, Leftmost Derivation)**
   - **Overview**: LL parsers are a class of top-down parsers that process the input from left to right and produce a leftmost derivation of the sentence. The number in LL(k) indicates that the parser looks ahead `k` tokens to make parsing decisions.
   - **How It Works**:
     - **LL(1) Parsing**: The parser uses a single token lookahead to decide which production rule to apply. This is the most common LL parser, where the decision is made based on the current input token and a parsing table.
     - **Parsing Table**: The LL(1) parser uses a table that maps non-terminals and lookahead tokens to specific production rules.
   - **Example**:
     - Grammar:
       ```plaintext
       S -> A B
       A -> 'a'
       B -> 'b'
       ```
     - Parsing table:
       ```plaintext
       | Non-terminal | 'a'  | 'b'  |
       |--------------|------|------|
       | S            | S -> A B  |
       | A            | A -> 'a'  |
       | B            |          | B -> 'b'  |
       ```
   - **Advantages**:
     - Simple and efficient for grammars that fit the LL(1) constraints.
   - **Disadvantages**:
     - Limited in the types of grammars it can handle (cannot handle left recursion or ambiguous grammars).

### 3. **LR Parsing (Left-to-right, Rightmost Derivation)**
   - **Overview**: LR parsers are bottom-up parsers that read input from left to right but construct a rightmost derivation in reverse. LR parsers are powerful and can handle a wider range of grammars, including those with left recursion and ambiguities.
   - **Variants of LR Parsing**:
     - **Simple LR (SLR)**: The simplest form of LR parsing. It uses a parsing table generated based on the Follow sets of the grammar.
     - **Canonical LR**: The most powerful and general form of LR parsing. It uses full lookahead information to make parsing decisions.
     - **LALR (Look-Ahead LR)**: A more efficient version of canonical LR that combines similar states in the parsing table. It’s commonly used because it strikes a balance between power and efficiency.
   - **How It Works**:
     - The parser uses a stack to keep track of the states and the symbols.
     - It uses a parsing table that consists of action and goto tables to decide whether to shift (push the input onto the stack) or reduce (apply a grammar rule).
     - **Shift**: Push the current input symbol onto the stack and advance the input.
     - **Reduce**: Replace a sequence of stack symbols that match the right-hand side of a production rule with the non-terminal on the left-hand side of the rule.
   - **Example**:
     - Grammar:
       ```plaintext
       E -> E + T | T
       T -> T * F | F
       F -> ( E ) | id
       ```
     - Actions:
       - **Shift**: Push the next input token onto the stack.
       - **Reduce**: Apply a production rule and replace the matched sequence on the stack.
   - **Advantages**:
     - Can handle a broader range of grammars than LL parsers, including left-recursive and ambiguous grammars.
   - **Disadvantages**:
     - More complex to implement and understand.
     - Requires a more complicated parsing table and larger memory footprint.

### 4. **Comparison of Techniques**
   - **Recursive Descent**: Suitable for simpler grammars without left recursion. Easy to implement manually but less efficient for complex grammars.
   - **LL Parsing**: Ideal for grammars that are naturally top-down, non-left-recursive, and unambiguous. LL(1) is the most common, but it’s limited in the types of grammars it can handle.
   - **LR Parsing**: The most powerful and general parsing method, capable of handling complex, ambiguous, and left-recursive grammars. However, it is more complex to implement.

### Conclusion
Different parsing techniques are suited to different types of grammars and applications. **Recursive descent** and **LL parsing** are great for simpler, more predictable grammars, while **LR parsing** is necessary for more complex and general-purpose language parsing. The choice of technique depends on the specific needs of the language and the complexity of the grammar being parsed.